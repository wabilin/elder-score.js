"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const flatDepth=(e,t)=>e.reduce((e,s)=>t>1&&Array.isArray(s)?e.concat(flatDepth(s,t-1)):e.concat(s),[]),{assign:assign,entries:entries,keys:keys,values:values}=Object,{isInteger:isInteger,isNaN:isNaN,isFinite:isFinite,isSafeInteger:isSafeInteger}=Number,{isArray:isArray}=Array,e={assign:assign,entries:entries,keys:keys,values:values,isInteger:isInteger,isNaN:isNaN,isFinite:isFinite,isSafeInteger:isSafeInteger,isArray:isArray,isArguments:e=>_.isObjectLike(e)&&"[object Arguments]"===e.toString(),isBoolean:e=>!0===e||!1===e,isObjectLike:e=>"object"==typeof e&&null!==e,compact:e=>e.filter(Boolean),difference(e,t){const s=new Set(t);return e.filter(e=>!s.has(e))},drop:(e,t=1)=>e.slice(t<0?0:t),dropRight:(e,t=1)=>e.slice(0,e.length-t),fromEntries(e){const t={};return e.forEach(([e,s])=>{t[e]=s}),t},flatten:(e,t=1)=>flatDepth(e,t),first:(e,t)=>t?e.slice(0,t):e[0],initial:(e,t=1)=>_.first(e,e.length-t),intersection(...e){if(0===e.length)return[];const t=[...new Set(e[0])],s=_.rest(e).map(e=>new Set(e));return t.filter(e=>s.every(t=>t.has(e)))},last(e,t){const{length:s}=e;return t?e.slice(s-t):e[s-1]},rest:(e,t=1)=>e.slice(t),take:(e,t=1)=>e.slice(0,t),union:(e,...t)=>_.uniq(e.concat(...t)),uniq:e=>[...new Set(e)],zip(...e){const t=_.max(e.map(e=>e.length)),s=[];for(let i=0;i<t;i+=1)s.push(e.map(e=>e[i]));return s},max:e=>Math.max(...e)},_=Object.assign({},e,{head:e.first,tail:e.rest});module&&(module.exports=_),exports.default=_;