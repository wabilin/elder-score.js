"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const flatDepth=(e,t)=>e.reduce((e,s)=>t>1&&Array.isArray(s)?e.concat(flatDepth(s,t-1)):e.concat(s),[]),{assign:assign,entries:entries,keys:keys,values:values}=Object,{isInteger:isInteger,isNaN:isNaN,isFinite:isFinite,isSafeInteger:isSafeInteger}=Number,{isArray:isArray}=Array,e={assign:assign,entries:entries,keys:keys,values:values,isInteger:isInteger,isNaN:isNaN,isFinite:isFinite,isSafeInteger:isSafeInteger,isArray:isArray,isArguments:e=>_.isObjectLike(e)&&"[object Arguments]"===e.toString(),isBoolean:e=>!0===e||!1===e,isEmpty:e=>null==e||(_.isArray(e)?0===e.length:_.isEmpty(keys(e))),isObjectLike:e=>"object"==typeof e&&null!==e,compact:e=>e.filter(Boolean),difference(e,t){const s=new Set(t);return e.filter(e=>!s.has(e))},fromEntries(e){const t={};return e.forEach(([e,s])=>{t[e]=s}),t},flatten:(e,t=1)=>flatDepth(e,t),first:(e,t)=>t?e.slice(0,t):e[0],initial:(e,t=1)=>_.first(e,e.length-t),intersection(...e){if(_.isEmpty(e))return[];const t=[...new Set(e[0])],s=_.rest(e).map(e=>new Set(e));return t.filter(e=>s.every(t=>t.has(e)))},last(e,t){const{length:s}=e;return t?e.slice(s-t):e[s-1]},rest:(e,t=1)=>e.slice(t),take:(e,t=1)=>e.slice(0,t),unzip:e=>_.isEmpty(e)?[]:e[0].map((t,s)=>e.map(e=>e[s])),without:(e,...t)=>_.difference(e,t),union:(e,...t)=>_.uniq(e.concat(...t)),uniq:e=>[...new Set(e)],zip(...e){const t=_.max(e.map(e=>e.length)),s=[];for(let i=0;i<t;i+=1)s.push(e.map(e=>e[i]));return s},max:e=>Math.max(...e)},_=Object.assign({},e,{head:e.first,tail:e.rest,drop:e.rest,dropRight:e.initial});exports.default=_;